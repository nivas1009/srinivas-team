# üé• AI-Powered Movie Recommendation System (Streamlit App)
# --------------------------------------------------------
# Created with ‚ù§Ô∏è and a sprinkle of AI magic.
# Run it locally: streamlit run app.py
# Requirements: streamlit, pandas, numpy, scikit-learn
# Pro tip: ‚≠ê Rate movies in the sidebar to see the AI learn your taste!

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.decomposition import TruncatedSVD

# üé® Streamlit Page Setup
st.set_page_config(page_title="üé¨ MovieSensei ‚Äì AI Movie Guru", layout="wide")

st.title("üé¨ MovieSensei ‚Äì Your AI Movie Guru")
st.markdown(
    "This is not just a recommender, it's your new **movie buddy**! üçø\n\n"
    "‚û°Ô∏è Rate a few movies in the sidebar, and watch the AI blend **content-based** (TF-IDF) and **collaborative filtering** (SVD magic) to find what you‚Äôll love next.\n"
    "You even get to tweak how much weight each method gets ‚Äì because hey, you‚Äôre the director here! üé¨"
)

# ---------- Mini Movie Catalog ----------
# (A hand-picked mini-IMDb curated by AI üòâ)
movies_data = [
    {"movieId": 1, "title": "The Shawshank Redemption", "genres": "Drama"},
    {"movieId": 2, "title": "The Godfather", "genres": "Crime|Drama"},
    {"movieId": 3, "title": "The Dark Knight", "genres": "Action|Crime|Drama"},
    {"movieId": 4, "title": "Pulp Fiction", "genres": "Crime|Drama"},
    {"movieId": 5, "title": "Forrest Gump", "genres": "Comedy|Drama|Romance"},
    {"movieId": 6, "title": "Inception", "genres": "Action|Adventure|Sci-Fi"},
    {"movieId": 7, "title": "Fight Club", "genres": "Drama"},
    {"movieId": 8, "title": "Interstellar", "genres": "Adventure|Drama|Sci-Fi"},
    {"movieId": 9, "title": "The Matrix", "genres": "Action|Sci-Fi"},
    {"movieId": 10, "title": "The Silence of the Lambs", "genres": "Crime|Drama|Thriller"},
    {"movieId": 11, "title": "Se7en", "genres": "Crime|Drama|Mystery"},
    {"movieId": 12, "title": "The Prestige", "genres": "Drama|Mystery|Sci-Fi"},
    {"movieId": 13, "title": "Gladiator", "genres": "Action|Adventure|Drama"},
    {"movieId": 14, "title": "Whiplash", "genres": "Drama|Music"},
    {"movieId": 15, "title": "The Lion King", "genres": "Animation|Adventure|Drama"},
    {"movieId": 16, "title": "Toy Story", "genres": "Animation|Adventure|Comedy"},
    {"movieId": 17, "title": "Back to the Future", "genres": "Adventure|Comedy|Sci-Fi"},
    {"movieId": 18, "title": "The Departed", "genres": "Crime|Drama|Thriller"},
    {"movieId": 19, "title": "Memento", "genres": "Mystery|Thriller"},
    {"movieId": 20, "title": "The Social Network", "genres": "Biography|Drama"},
    {"movieId": 21, "title": "Mad Max: Fury Road", "genres": "Action|Adventure|Sci-Fi"},
    {"movieId": 22, "title": "Parasite", "genres": "Comedy|Drama|Thriller"},
    {"movieId": 23, "title": "The Grand Budapest Hotel", "genres": "Adventure|Comedy|Drama"},
    {"movieId": 24, "title": "La La Land", "genres": "Comedy|Drama|Music"},
    {"movieId": 25, "title": "Blade Runner 2049", "genres": "Action|Drama|Sci-Fi"},
    {"movieId": 26, "title": "Spirited Away", "genres": "Animation|Adventure|Family"},
    {"movieId": 27, "title": "The Truman Show", "genres": "Comedy|Drama|Sci-Fi"},
    {"movieId": 28, "title": "A Beautiful Mind", "genres": "Biography|Drama"},
    {"movieId": 29, "title": "Casino Royale", "genres": "Action|Adventure|Thriller"},
    {"movieId": 30, "title": "Oldboy", "genres": "Action|Drama|Mystery"},
]

movies = pd.DataFrame(movies_data)
movies['metadata'] = movies['title'] + ' | ' + movies['genres'].str.replace('|', ' ')

# ---------- Generate Some Fake Ratings (Synthetic Data) ----------
np.random.seed(42)
user_ids = list(range(1, 9))
ratings_list = []
for uid in user_ids:
    for m in movies['movieId'].sample(10, random_state=uid):
        rating = np.random.choice([3, 4, 5], p=[0.2, 0.5, 0.3])
        ratings_list.append({'userId': uid, 'movieId': int(m), 'rating': rating})

ratings = pd.DataFrame(ratings_list)

# ---------- Build Content-Based Model ----------
@st.cache_data
def build_content_sim_matrix(df):
    tf = TfidfVectorizer(stop_words='english')
    tfidf_matrix = tf.fit_transform(df['metadata'])
    sim = cosine_similarity(tfidf_matrix)
    return sim

content_sim = build_content_sim_matrix(movies)

# ---------- Build Collaborative Model (Mini SVD) ----------
@st.cache_data
def build_collab_latent(ratings_df, movies_df, n_components=12):
    users = sorted(ratings_df['userId'].unique())
    movie_ids = movies_df['movieId'].tolist()
    user_index = {u:i for i,u in enumerate(users)}
    movie_index = {m:i for i,m in enumerate(movie_ids)}

    mat = np.zeros((len(users), len(movie_ids)))
    for _, row in ratings_df.iterrows():
        if row['movieId'] in movie_index:
            mat[user_index[row['userId']], movie_index[row['movieId']]] = row['rating']

    if mat.shape[0] < n_components:
        n_components = max(2, mat.shape[0] - 1)
    svd = TruncatedSVD(n_components=n_components, random_state=42)
    user_latent = svd.fit_transform(mat)
    item_latent = svd.components_.T
    return users, movie_ids, user_latent, item_latent

users, movie_ids, user_latent, item_latent = build_collab_latent(ratings, movies)
movie_id_to_index = {m:i for i,m in enumerate(movie_ids)}

# ---------- Let Users Rate Movies in Sidebar ----------
st.sidebar.header("üçø Rate Movies")
user_ratings = {}
for idx, row in movies.sample(12, random_state=7).iterrows():
    rating = st.sidebar.slider(f"{row['title']}", 0, 5, 0, key=f"r{row['movieId']}")
    if rating > 0:
        user_ratings[int(row['movieId'])] = rating

if not user_ratings:
    st.sidebar.info("üëÜ Rate at least one movie to unlock recommendations!")

# ---------- Recommendation Settings ----------
top_n = st.sidebar.number_input('üéØ Number of Recommendations', min_value=5, max_value=20, value=8)
content_weight = st.sidebar.slider('‚öñÔ∏è Content-based weight', 0.0, 1.0, 0.5)

# ---------- Compute Personalized Recommendations ----------
def map_user_to_latent(user_ratings_dict, movie_index_map, item_latent):
    if not user_ratings_dict:
        return np.zeros(item_latent.shape[1])
    weighted = np.zeros(item_latent.shape[1])
    weight_sum = 0.0
    for mid, r in user_ratings_dict.items():
        if mid in movie_index_map:
            idx = movie_index_map[mid]
            w = r - 3
            weighted += w * item_latent[idx]
            weight_sum += abs(w)
    if weight_sum == 0:
        return np.zeros(item_latent.shape[1])
    return weighted / weight_sum

new_user_latent = map_user_to_latent(user_ratings, movie_id_to_index, item_latent)

def predict_collab_for_user(user_vector, item_latent):
    return item_latent.dot(user_vector)

def get_hybrid_recommendations(user_ratings_dict, top_n=10, content_w=0.5):
    liked = [mid for mid, r in user_ratings_dict.items() if r >= 4]
    if liked:
        liked_indices = [movie_id_to_index[mid] for mid in liked if mid in movie_id_to_index]
        content_scores = content_sim[liked_indices].mean(axis=0)
    else:
        content_scores = np.zeros(len(movies))

    collab_scores = predict_collab_for_user(new_user_latent, item_latent)

    def normalize(x):
        if np.max(x) == np.min(x):
            return np.zeros_like(x)
        return (x - np.min(x)) / (np.max(x) - np.min(x))

    c_norm = normalize(content_scores)
    p_norm = normalize(collab_scores)

    hybrid = content_w * c_norm + (1 - content_w) * p_norm

    rated_set = set(user_ratings_dict.keys())
    candidates = [(movies.iloc[i]['movieId'], hybrid[i], c_norm[i], p_norm[i]) for i in range(len(movies)) if movies.iloc[i]['movieId'] not in rated_set]
    candidates.sort(key=lambda x: x[1], reverse=True)
    return candidates[:top_n]

recommendations = get_hybrid_recommendations(user_ratings, top_n=top_n, content_w=content_weight)

# ---------- Display Recommendations with Personality ----------
left, right = st.columns([2, 3])
with left:
    st.subheader('üéüÔ∏è Your Ratings')
    if user_ratings:
        rated_df = pd.DataFrame([{
            'Title': movies.loc[movies['movieId']==mid, 'title'].values[0],
            'Rating': r
        } for mid, r in user_ratings.items()])
        st.table(rated_df.sort_values('Rating', ascending=False))
    else:
        st.write('üëÄ No ratings yet ‚Äì time to share your taste!')

with right:
    st.subheader('üî• Top Picks For You')
    if recommendations:
        for mid, score, cscore, pscore in recommendations:
            mrow = movies[movies['movieId']==mid].iloc[0]
            st.markdown(f"**üé¨ {mrow['title']}** ‚Äî **Score:** {score:.3f}")
            st.caption(f"Genres: {mrow['genres']} ¬∑ üß† ContentScore: {cscore:.3f} ¬∑ ü§ù CollabScore: {pscore:.3f}")
            st.write("---")
    else:
        st.write('üôÉ No suggestions yet ‚Äî rate a movie or two!')
